#!/bin/bash

# chkconfig: 345 90 90
# description: Azkaban Solo server

### BEGIN INIT INFO
# Provides:       azkaban-solo
# Required-Start: $remote_fs $network
# Required-Stop:  $remote_fs $network
# Default-Start:  2 3 4 5
# Default-Stop:   0 1 6
# Description:    Azkaban Solo server service script
### END INIT INFO

service=azkaban-solo


##
# Setting defaults
AZKABAN_USER="azkaban"
AZKABAN_GROUP="azkaban"
AZKABAN_HOME="/opt/azkaban-solo"
AZAKBAN_CONF="${AZKABAN_HOME}/conf"
AZKABAN_TMP="/tmp"
AZKABAN_EXECUTOR_PORT=12321
AZKABAN_OPTS=""


##
# Service settings
SERVICE_MAX_WAIT=10
PID_DIR="/var/run/${service}"
LOG_DIR="/var/log/${service}"


##
# source platform specific(debian) external scripts
. /lib/lsb/init-functions

[ -r /etc/default/${service} ] && . /etc/default/${service}


echo_ok( ) {

  log_end_msg 0
}


echo_fail( ) {

  log_end_msg 1
}


lockfile=${LOCKFILE:-/var/lock/${service}}
pattern="__AZKABAN_SOLO__"
pidfile=${PID_DIR}/${service}.pid
logfile=${LOG_DIR}/${service}_service.log


ensure_dir( ) {
  local directory="${1}"
  local user=${2:-${AZKABAN_USER}}
  local permissions=${3:-0755}

  if [ ! -d "${directory}" ]; then

    mkdir -p "${directory}"
    chown -R ${user} "${directory}"
    chmod ${permissions} "${directory}"
  fi
}


##
# Start the service
_do_start( ) {
  local classpath=""

  log_daemon_msg "Starting ${service}"

  [ -x "${JAVA_HOME}/jre/bin/java" ] || exit 5

  _do_status &> /dev/null

  if [ ${?} -eq 0 ]; then

    log_action_msg "${service} is already running."
    echo_ok
    exit 0
  fi

  ensure_dir ${PID_DIR} ${AZKABAN_USER}
  ensure_dir ${LOG_DIR} ${AZKABAN_USER}

  ##
  # Do some dirty stuffs for the JVM
  for file in ${AZKABAN_HOME}/lib/*.jar; do
    classpath=${classpath}:${file}
  done 2>/dev/null

  for file in ${AZKABAN_HOME}/extlib/*.jar; do
    classpath=${classpath}:${file}
  done 2>/dev/null

  for file in ${AZKABAN_HOME}/plugins/*.jar; do
    classpath=${classpath}:${file}
  done 2>/dev/null

  if [ -n "${HADOOP_HOME}" ]; then

    classpath=${classpath}:${HADOOP_HOME}/conf:${HADOOP_HOME}/lib/*
    options="${options} -Djava.library.path=${HADOOP_HOME}/lib/native/Linux-amd64-64"
  fi

  if [ -n "${HIVE_HOME}" ]; then

    classpath=${classpath}:${HIVE_HOME}/conf:${HIVE_HOME}/lib/*
  fi

  su - ${AZKABAN_USER} -c "${JAVA_HOME}/jre/bin/java -D${pattern} ${AZKABAN_OPTS} -classpath ${classpath} azkaban.webapp.AzkabanSingleServer -conf ${AZKABAN_CONF} 2>/dev/null &"

  retval=${?}
  sleep 1

  pid=$(ps -e -o pid,command | grep -v grep | grep ${pattern} | cut -f1 -d" ")
  echo "${pid}" > ${pidfile}

  # make sure it's still running. some errors occur only after startup
  _do_status &> /dev/null
  if [ $? -ne 0 ]; then

    echo_fail
    exit 1
  fi

  [ ${retval} -eq 0 ] && touch ${lockfile}

  echo_ok

  return ${retval}
}


##
# Stops the service
_do_stop( ) {
   
  log_daemon_msg "Stopping ${service}"

  if [ -f ${pidfile} ]; then

    killproc -p ${pidfile} ${service}
    retval=${?}

    if [ ${retval} -eq 0 ]; then

      rm -f ${pidfile}
      rm -f ${lockfile}

      echo_ok
    else

      echo_fail
    fi

    sleep 1
    return $retval
  else
    pid=$(ps -e -o pid,command | grep -v grep | grep "${pattern}" | awk '{ print $1 }')

    if [ -n "${pid}" ]; then

      kill ${pid}
      retval=${?}

      if [ ${retval} -eq 0 ]; then

        rm -f ${pidfile}
        rm -f ${lockfile}

        echo_ok
      else

        echo_fail
      fi

      sleep 1
      return ${retval}
    else

      echo_fail
    fi
  fi
}


##
# Get the status of the service
_do_status( ) {

  local pid=""

  # 1.- try "ps"
  pid=$(ps -e -o pid,command | grep -v grep | grep "${pattern}" |  awk '{ print $1 }')

  if [ -n "${pid}" ]; then

    log_action_msg "$service (pid $pid) is running"
    return 0
  fi

  # 2.- try "/var/run/*.pid" files
  if [ -f "${pidfile}" ]; then

    read pid < "${pidfile}"
    if [ -n "${pid}" ]; then

      log_action_msg "${service} dead but pid file exists"
      return 1
    fi
  fi

  # See if lock file exist
  if [ -f "${lockfile}" ]; then

    log_action_msg "${service} dead but subsys locked"
    return 2
  fi

  log_action_msg "${service} is stopped"
  return 3
}


##
# Stops the service
_do_restart( ) {
  local count=0
  local success=0

  _do_stop

  while [ ${count} -lt ${SERVICE_MAX_WAIT} ]; do

    count=$((count + 1))
    _do_status &> /dev/null

    if [ ${?} -eq 0 ]; then
      # still running
      sleep 1
    else
      success=1
      break
    fi
  done

  if [ ${success} = 1 ]; then

    _do_start
  else

    log_failure_msg "Timed out waiting for ${service} to stop"
    return 1
  fi
}


##
# ::main::
case "${1}" in
  start|stop|status|restart)
    _do_${1}
    ;;

  *)
    echo "Usage: ${0} {start|stop|status|restart}"
    exit 2
    ;;
esac


exit $?

